// ⚠️ GENERATED CODE ⚠️
// This entire file was generated by the `roc glue` CLI command and then manually mofidied
//
// Here was the platform used to generate this file:
// ```
// platform ""
//     requires {} { main : _ }
//     exposes []
//     packages {}
//     imports []
//     provides [mainForHost]

// HostPath : [Windows (List U16), Unix (List U8)]

// mainForHost : HostPath
// mainForHost = main
// ```

#![allow(dead_code)]

use roc_std::roc_refcounted_noop_impl;
use roc_std::RocRefcounted;

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum HostPathDiscriminant {
    Unix = 0,
    Windows = 1,
}

impl core::fmt::Debug for HostPathDiscriminant {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Unix => f.write_str("HostPath::Unix"),
            Self::Windows => f.write_str("HostPath::Windows"),
        }
    }
}

roc_refcounted_noop_impl!(HostPathDiscriminant);

#[repr(C, align(8))]
pub union union_HostPath {
    Unix: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
    Windows: core::mem::ManuallyDrop<roc_std::RocList<u16>>,
}

const SIZE_CHECK_UNION_HOST_PATH: () = assert!(core::mem::size_of::<union_HostPath>() == 24);
const ALIGN_CHECK_UNION_HOST_PATH: () = assert!(core::mem::align_of::<union_HostPath>() == 8);

const SIZE_CHECK_HOST_PATH: () = assert!(core::mem::size_of::<HostPath>() == 32);
const ALIGN_CHECK_HOST_PATH: () = assert!(core::mem::align_of::<HostPath>() == 8);

#[repr(C)]
pub struct HostPath {
    payload: union_HostPath,
    discriminant: HostPathDiscriminant,
}

impl Clone for HostPath {
    fn clone(&self) -> Self {
        use HostPathDiscriminant::*;

        let payload = unsafe {
            match self.discriminant {
                Unix => union_HostPath {
                    Unix: self.payload.Unix.clone(),
                },
                Windows => union_HostPath {
                    Windows: self.payload.Windows.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for HostPath {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use HostPathDiscriminant::*;

        unsafe {
            match self.discriminant {
                Unix => {
                    let field: &roc_std::RocList<u8> = &self.payload.Unix;
                    f.debug_tuple("HostPath::Unix").field(field).finish()
                }
                Windows => {
                    let field: &roc_std::RocList<u16> = &self.payload.Windows;
                    f.debug_tuple("HostPath::Windows").field(field).finish()
                }
            }
        }
    }
}

impl Eq for HostPath {}

impl PartialEq for HostPath {
    fn eq(&self, other: &Self) -> bool {
        use HostPathDiscriminant::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Unix => self.payload.Unix == other.payload.Unix,
                Windows => self.payload.Windows == other.payload.Windows,
            }
        }
    }
}

impl Ord for HostPath {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for HostPath {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use HostPathDiscriminant::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Unix => self.payload.Unix.partial_cmp(&other.payload.Unix),
                    Windows => self.payload.Windows.partial_cmp(&other.payload.Windows),
                }
            },
        }
    }
}

impl core::hash::Hash for HostPath {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use HostPathDiscriminant::*;

        unsafe {
            match self.discriminant {
                Unix => self.payload.Unix.hash(state),
                Windows => self.payload.Windows.hash(state),
            }
        }
    }
}

impl HostPath {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> HostPathDiscriminant {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, HostPathDiscriminant>(*bytes.as_ptr().add(24))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: HostPathDiscriminant) {
        let discriminant_ptr: *mut HostPathDiscriminant = (self as *mut HostPath).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }

    pub fn unwrap_unix(mut self) -> roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, HostPathDiscriminant::Unix);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Unix) }
    }

    pub fn borrow_unix(&self) -> &roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, HostPathDiscriminant::Unix);
        use core::borrow::Borrow;
        unsafe { self.payload.Unix.borrow() }
    }

    pub fn borrow_mut_unix(&mut self) -> &mut roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, HostPathDiscriminant::Unix);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Unix.borrow_mut() }
    }

    pub fn is_unix(&self) -> bool {
        matches!(self.discriminant, HostPathDiscriminant::Unix)
    }

    pub fn unwrap_windows(mut self) -> roc_std::RocList<u16> {
        debug_assert_eq!(self.discriminant, HostPathDiscriminant::Windows);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Windows) }
    }

    pub fn borrow_windows(&self) -> &roc_std::RocList<u16> {
        debug_assert_eq!(self.discriminant, HostPathDiscriminant::Windows);
        use core::borrow::Borrow;
        unsafe { self.payload.Windows.borrow() }
    }

    pub fn borrow_mut_windows(&mut self) -> &mut roc_std::RocList<u16> {
        debug_assert_eq!(self.discriminant, HostPathDiscriminant::Windows);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Windows.borrow_mut() }
    }

    pub fn is_windows(&self) -> bool {
        matches!(self.discriminant, HostPathDiscriminant::Windows)
    }
}

impl From<roc_std::RocList<u8>> for HostPath {
    fn from(payload: roc_std::RocList<u8>) -> Self {
        Self::Unix(payload)
    }
}

impl From<roc_std::RocList<u16>> for HostPath {
    fn from(payload: roc_std::RocList<u16>) -> Self {
        Self::Windows(payload)
    }
}

impl HostPath {
    pub fn Unix(payload: roc_std::RocList<u8>) -> Self {
        Self {
            discriminant: HostPathDiscriminant::Unix,
            payload: union_HostPath {
                Unix: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn Windows(payload: roc_std::RocList<u16>) -> Self {
        Self {
            discriminant: HostPathDiscriminant::Windows,
            payload: union_HostPath {
                Windows: core::mem::ManuallyDrop::new(payload),
            },
        }
    }
}

impl Drop for HostPath {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            HostPathDiscriminant::Unix => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Unix)
            },
            HostPathDiscriminant::Windows => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Windows)
            },
        }
    }
}

impl roc_std::RocRefcounted for HostPath {
    fn inc(&mut self) {
        match self.discriminant() {
            HostPathDiscriminant::Unix => unsafe {
                (*self.payload.Unix).inc();
            },
            HostPathDiscriminant::Windows => unsafe {
                (*self.payload.Windows).inc();
            },
        }
    }
    fn dec(&mut self) {
        match self.discriminant() {
            HostPathDiscriminant::Unix => unsafe {
                (*self.payload.Unix).dec();
            },
            HostPathDiscriminant::Windows => unsafe {
                (*self.payload.Windows).dec();
            },
        }
    }
    fn is_refcounted() -> bool {
        true
    }
}
